#####测试环节：
1. 启动8080，查看相关日志，是否按时发送vote给其他node。有无其他错误。
当超时时是否再次发送vote。状态是否一直是candidate

-- ok，日志顺序正确，没有明显错误，每次都新生成【选举超时】，这是关键，
能防止大家都同一时间发送，然后等待同一时间，然后再同时发送。

2. 接上面启动8081
当8080当收到vote回应时查看信息是否正确，是否超过半数则成为leader，
当成为leader时，是否发送心跳，是否不再发送vote。查看是否一直持续
发送heartbeat。查看下次TimeElection的醒来时间是否是上次规定睡眠时间。
查看heartbeat版本是否不变。

--ok

3. 查看8081相关日志，查看是否等待投票，查看是否收到vote请求，查看是否
收到heartbeat。查看heartbeat频率是否变更以及是否发送vote。

--ok，开始等待，然后持续收到heartbeat，频率一致。不在发送vote,每次都重新计算超时时间

4. 停止8080，查看8081日志，看看是否重新投票，最大容忍也就是上次收到心跳后重置的超时时间，
是否变成leader，是否发送心跳。

--ok,继续上次term，超时后进行投票。未达到多数，所以还是candidate。不断增长term发送vote。

5. 启动8080，查看8081和8080日志，是否和上面执行的一样。

--ok,8081发起投票，变成leader，然后不断发送heartbeat重置超时时间，并未再次vote，也并未收到
任何vote和heartbeat。
8080等待，收到vote，然后变更term，每次收到heartbeat后重置超时时间.

6. 重新启动
8080做主，8081做从，暂停8080(停止发送心跳)，查看8081日志，看看是否重新投票，
最大容忍也就是上次收到心跳后重置的超时时间，是否变成leader，是否发送心跳。
查看8080日志。

--ok
8081重新发起投票。没有收到任何vote响应，因为suspend all了。。

7. 打开8080后，查看8080日志，查看8081日志。
8080收到大量[http-nio-8080-exec-x]，应该是tomcat刚才挤压的投票请求，而且应该是舍弃了
比较靠前的请求，而且由于是线程池还都不是顺序执行。有的同意，有的拒绝，因为自己的term低。
但是应该禁止heartbeat才对，哦，是由于上面和heartbeat使用的一个锁TimeElection.waitObject导致的，
开始还以为是由于共用线程了呢，那应该不可能。由于不是leader，所以heartbeat长久等待。接收heartbeat重置超时时间.
8081不断投票没人回应，打开8080后，收到heartbeat，由于版本低，直接拒绝，收到大量vote回应，
但是由于term不一致即使ip一致也不行。所以大量not vote for me。当收到相同term和ipprot时，即收到
大多数投票了，转成leader。发送心跳等操作。


8. 重新启动
8080做主，8081做从，暂停8080(停止发送心跳,这会只停止当前线程)，查看8081日志，看看是否重新投票，
最大容忍也就是上次收到心跳后重置的超时时间，是否变成leader，是否发送心跳。
查看8080日志。

--ok
8080由于停止发送heartbeat。election time也不能重置，收到8081的投票了，重置超时时间，
维持在一个term期间。
8081没有收到heartbeat，超时后发起投票,同意，成为leader，开心heartbeat，设置超时标识。
持续发送heartbeat和设定isNeedContinueWait。
开启8080的heartbeat心跳线程后，
8080由于不是leader，所以心跳线程长时间等待。还是长时间收到心跳，重置超时时间。
对8081没有影响，还是继续发送heartbeat，即使有heartbeat，也会由于term小被拒绝。

9. 单独试了一下停止8080心跳线程，，
由于8080停止开后，还阻塞了大量的[http-nio-8081-exec-xx]投票请求，放开后，
8081日志，由于新的投票大于8081自己term小，所以8081同意了，
然后变成follower，由于自己不是leader了停止发送heartbeat。但是呢由于8080心跳线程还暂停中，没有发
送过来heartbeat，然后8081超时之后又发送了vote。。变成了leader。但是呢，程序有问题，leader只能启动一次
heartbeat！所以还一直发送vote，一直成为leader。。好有意思啊。。
8080日志，
由于heartbeat线程停止了，所以超时时间过了发起投票，变成leader，但是程序错误：heartbeat只能初始化一次，
所以不断投票，不断leader。。但是发送不了heartbeat，8081还能再发起vote，然后收到vote后者发起vote。。
以上都是因为heartbeat只能初始化一次，而大家看谁先醒来，然后发起投票，然后成为leader，但是不发送heartbeat，
然后大家都再睡再超时再发起vote。。
看来若触发不了heartbeat或者heartbeat线程阻塞，那么大家就会一直在争抢leader，但是还坐不住。。
若是超时选举线程阻塞或触发不了，那么一旦heartbeat由于角色变更不能发送，那么大家都被投票了。。
看来谁也不能有事啊，是不是这就是最少3个元素而且要是奇数的原因。。要是3个的话有一个挂了，或者阻塞，
其他俩还能玩，容忍一个挂。上面的场景就2，所以一个有问题，那么整体都别玩了。

#####插曲：锁粒度减小
本身设计时，lock就是单纯的为了wait而使用的，当然后来用wait也会被主动唤醒进行重置时间。
不用占用那么多lock时间，也没有那么多需要进行同步的，各自选举和心跳各自玩各自的，只不过
当心跳来时，需要重置一下选举超时时间而已。

由于修改锁力度后查看8080和8081的日志状况以及选举、心跳。

--ok，正常，开始直接心跳，不过非leader就一直等待了，

10. 启动8082，查看相关日志，查看是否等待投票，查看是否收到vote，查看是否
收到heartbeat。查看heartbeat频率以及是否发送vote。

--ok,8080是leader，heartbeat到8082的好了，不报错了。日志都是发送心跳+设置isNeedContinueWait
和偶尔的超时自己重置。
8081都是接收heartbeat并重置超时时间。
8082除了启动时超时等待，心跳启动，其他的和8081一样。

11. 停止8080，查看8081是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。
查看8082是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。

--ok
8081等待超时后发起投票成为leader并发送心跳。
8082比8081多睡了2s就被抢占了leader。持续受到heartbeat。

12. 暂停了8080和8082的心跳线程，查看所有日志是否正常。
--ok
8080暂停后，接收到vote请求，同意，一直收到8082的投票，但是8082这也被停止心跳线程了，所以大家都等他他的心跳
而迟迟等不到，然后打开8080后，发送了一个剩余心跳，2s后意识到自己不是leader，停止心跳，接收到8081的投票，同意，
接收到8081的心跳。似乎一会打开8082后，8082发送了一个当前term的心跳，8080承认了。。好像应该是将变量局限在内部
8081接收不到8080心跳，超时后发起vote，收到vote回应是8082他投他自己，再醒来就是接收8082的更高投票，同意，
同样迟迟未收到heartbeat。这时收到了8080的高term心跳(可能是打开后)，然后同意了。。都没有心跳，那自己又投票，
成为leader，发送心跳。似乎应该控制接收心跳机制，相同ip则term相同，若是ip不同那么需要更高一级的term？
8082接收不到8080心跳，超时后发起vote，收到大多数vote，成为leader，但是心跳线程暂停了。继续投票，继续leader，
直到接收到8081的高term的vote，然后同意，然后接收8081的heartbeat，打开后，发送剩余heartbeat，意识到
自己不是leader，那停止heartbeat。

13. 修复localnode引用溢出问题进行测试上面场景。
--ok
暂停8080心跳线程后，收到两个vote(8081/8082)都拒绝了，自己超时后发送投票，依次循环，感觉他们的term不涨呢？
8081，不收心跳超市后发送投票，term低被拒绝，一直被8080牵着走，似乎两者的term不能同步！
8082同样的问题

######localNode变更时机
超时时间后，变成candidate，+term，votefor自己。
收到半数以上vote的回应后修改成leader。
收到投票、心跳后若是远程term大则修改自己的term，votefor，state
若是发生之间的交叉操作，已最后的为准，因为都有term保证,之后的操作会趋向于最后的正确状态?

情景1：先超时，取，然后心跳到了，更新，再超时更新
8080term是3，超时了，取出来是3然后+1为4，准备更新clusterManger，但是这时有8081heartbeat的term为4
那么clusterManger变更了term=4，但是votefor是8081,然后又设定了votefor自己，然后发起投票，
8081持续发送心跳，当到8080的vote请求拒绝。8080的vote被拒绝，收到heartbeat时自然就更新了自己状态和votefor。
最后还是用随机超时看谁的term高同意谁。可能会延长服务不可用时间。

情景2：先超时，取，更新，然后心跳到了，更新
8080term是3，超时了，取出来是3然后+1为4，更新clusterManger，vote自己。但是这时有8081heartbeat的term为4
那么clusterManger变更了term=4，votefor改成8081,刚才发送的vote自然不会被已经为term4的8081同意，
所以还是拒绝了。

14. 修复localnode不变更问题,再次进行上面测试
--ok
8080不发送心跳了，收到8082的vote，但是8082成为leader后同样阻塞了心跳线程，所以8080超时后再发送vote，成为leader，
但是发送不了心跳，恢复后发送心跳,即上次投票我是leader虽然没有心跳但是我还是leader！一旦恢复心跳我马上就发送。
8081，未收到心跳后，收到8082的vote，但是8082发送不了心跳，所以持续收到8080/8082的vote并重置自己的超时时间，
当8080恢复后，发送一个老term的heartbeat拒绝，又发送了一个高term的heartbeat，当8082恢复后收到一个低term拒绝.
一直收到8080的heartbeat。
8082，未收到心跳后，发送vote，成为leader，但是发送不了heartbeat。收到8080的高term的vote，8080恢复后，
8082收到低term的heartbeat，拒绝，高term的heartbeat同意。
以上之所以会发生一会8080或8082发送vote，是因为各自没有heartbeat保持自己地位让其他node重置时间，而自己
还是异步发送，之后还在等待，所以谁先醒来谁还会继续发送。

15. 仅仅暂停8080，查看8081是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。
查看8082是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。
查看8080相关日志。
然后继续8080，查看term相关是否导致他的heartbeat被拒绝，然后他是否
能成为follower，然后查看8081和8082的反应。

-- ok
8080停止心跳后，收到8081请求同意，持续收到8081心跳。恢复后，发送低term的heartbeat，然后暂停heartbeat。
8081未接受到heartbeat后进行vote，成为leader，持续发送heartbeat，8080恢复后，8081接收到低term，拒绝。
8082未收到8080心跳后，收到8081的vote请求，同意，持续收到8081的heartbeat，当收到8080恢复后的heartbeat，
由于term低，拒绝。

16. 停止非leader机器8081，查看leader和其他follower的反应。
再启动8081，查看所有机器的日志。

-- ok
对于8080，没有什么影响，只不过有一个heartbeat发送失败。还是不断设置isNeedContinueWait并发送hearbeat
对8082更没影响，持续收到8080的心跳，重置超时时间
启动8081后，
8080发送hearbeat的线程不报错了，持续发送hearbeat。
8081收到heartbeat之后同步term，然后持续接收heartbeat并重置超时时间。
8080无影响。

17. 查看genElectionTime生成次数是否过多。
genElectionTime发生时机：
- 超时选举线程初始化时构造
- 超时醒来后构造时间后异步发送vote
所以只有超时到了才调用genElectionTime，而持续收到heartbeat则不会超时。应该是网络大量不稳定时会产生大量。

18. 发送投票了，然后收到vote了如何办？收到heartbeat如何办？
发送则表明自己长时间未发送过心跳，或收到心跳。自己转换成candidate，然后发送vote请求。
若此时收到vote，那么看term，只有比我的大，我才能退化follower否则我还坚持等到vote响应，若大多数同意则
成为leader，否则等待下一个超时。
若此时收到heartbeat，也是比对term，大于等于我的term才能让我退化到follower，包含等于的原因是当时有人发给
我vote时，我同意了，所以大家在同一个term，而他在此次term发送heartbeat是合理的。

19. 有无并发问题？genElectionTime
不会。因为一个进程中，只有一个线程操作，若是多个线程操作也没有事，都是局部变量。似乎不对。。
改成ThreadLocalRandom

20. 查看交替leader场景。8080当leader，停止心跳，其他当leader之后再恢复8080，查看三次交替leader是否正确
8080停止后，8081收到8082的高temr的vote，持续收到8082的heartbeat。
8082未接收到heartbeat后，发起vote请求，成为leader，发送heartbeat。发给8080的失败。
启动8080，
8080收到高term的heartbeat。发现bug修正后测试

21. 测试上面场景
--ok
启动8080，
8080收到高term的heartbeat。
8081无影响
8082不报错了，一直leader发送hartbeat。
依次重启其他机器结果一致。

22. 线程阻塞或停止了如何？
应最小化阻塞线程并尽快执行。本raft只处理了选举，raft能解决的是部分网络不可用或延迟情况下的ap，
通过大多数成员的协商达到一致。
线程停止，只能说代码有问题。阻塞只能最小化并发场景，并减少阻塞耗时的操作。