#####测试环节：
1. 启动8080，查看相关日志，是否按时发送vote给其他node。有无其他错误。
当超时时是否再次发送vote。状态是否一直是candidate

-- ok，日志顺序正确，没有明显错误，每次都新生成【选举超时】，这是关键，
能防止大家都同一时间发送，然后等待同一时间，然后再同时发送。

启动8081

当8080当收到vote回应时查看信息是否正确，是否超过半数则成为leader，
当成为leader时，是否发送心跳，是否不再发送vote。查看是否一直持续
发送heartbeat。查看下次TimeElection的醒来时间是否是上次规定睡眠时间。
查看heartbeat版本是否不变。

--ok

查看8081相关日志，查看是否等待投票，查看是否收到vote请求，查看是否
收到heartbeat。查看heartbeat频率是否变更以及是否发送vote。

--ok，开始等待，然后持续收到heartbeat，频率一致。不在发送vote,每次都重新计算超时时间

停止8080，查看8081日志，看看是否重新投票，最大容忍也就是上次收到心跳后重置的超时时间，
是否变成leader，是否发送心跳。

--ok,继续上次term，超时后进行投票。未达到多数，所以还是candidate。不断增长term发送vote。

启动8080，查看8081和8080日志，是否和上面执行的一样。

--ok,8081发起投票，变成leader，然后不断发送heartbeat重置超时时间，并未再次vote，也并未收到
任何vote和heartbeat。
8080等待，收到vote，然后变更term，每次收到heartbeat后重置超时时间.

重新启动
8080做主，8081做从，暂停8080(停止发送心跳)，查看8081日志，看看是否重新投票，
最大容忍也就是上次收到心跳后重置的超时时间，是否变成leader，是否发送心跳。
查看8080日志。

--ok
8081重新发起投票。没有收到任何vote响应，因为suspend all了。。

打开8080后，查看8080日志，查看8081日志。

8080收到大量[http-nio-8080-exec-x]，应该是tomcat刚才挤压的投票请求，而且应该是舍弃了
比较靠前的请求，而且由于是线程池还都不是顺序执行。有的同意，有的拒绝，因为自己的term低。
但是应该禁止heartbeat才对，哦，是由于上面和heartbeat使用的一个锁TimeElection.waitObject导致的，
开始还以为是由于共用线程了呢，那应该不可能。由于不是leader，所以heartbeat长久等待。接收heartbeat重置超时时间.
8081不断投票没人回应，打开8080后，收到heartbeat，由于版本低，直接拒绝，收到大量vote回应，
但是由于term不一致即使ip一致也不行。所以大量not vote for me。当收到相同term和ipprot时，即收到
大多数投票了，转成leader。发送心跳等操作。


重新启动
8080做主，8081做从，暂停8080(停止发送心跳,这会只停止当前线程)，查看8081日志，看看是否重新投票，
最大容忍也就是上次收到心跳后重置的超时时间，是否变成leader，是否发送心跳。
查看8080日志。

--ok
8080由于停止发送heartbeat。election time也不能重置，收到8081的投票了，重置超时时间，
维持在一个term期间。
8081没有收到heartbeat，超时后发起投票,同意，成为leader，开心heartbeat，设置超时标识。
持续发送heartbeat和设定isNeedContinueWait。
开启8080的heartbeat心跳线程后，
8080由于不是leader，所以心跳线程长时间等待。还是长时间收到心跳，重置超时时间。
对8081没有影响，还是继续发送heartbeat，即使有heartbeat，也会由于term小被拒绝。

单独试了一下停止8080心跳线程，，
由于8080停止开后，还阻塞了大量的[http-nio-8081-exec-xx]投票请求，放开后，
8081日志，由于新的投票大于8081自己term小，所以8081同意了，
然后变成follower，由于自己不是leader了停止发送heartbeat。但是呢由于8080心跳线程还暂停中，没有发
送过来heartbeat，然后8081超时之后又发送了vote。。变成了leader。但是呢，程序有问题，leader只能启动一次
heartbeat！所以还一直发送vote，一直成为leader。。好有意思啊。。
8080日志，
由于heartbeat线程停止了，所以超时时间过了发起投票，变成leader，但是程序错误：heartbeat只能初始化一次，
所以不断投票，不断leader。。但是发送不了heartbeat，8081还能再发起vote，然后收到vote后者发起vote。。
以上都是因为heartbeat只能初始化一次，而大家看谁先醒来，然后发起投票，然后成为leader，但是不发送heartbeat，
然后大家都再睡再超时再发起vote。。
看来若触发不了heartbeat或者heartbeat线程阻塞，那么大家就会一直在争抢leader，但是还坐不住。。
若是超时选举线程阻塞或触发不了，那么一旦heartbeat由于角色变更不能发送，那么大家都被投票了。。
看来谁也不能有事啊，是不是这就是最少3个元素而且要是奇数的原因。。要是3个的话有一个挂了，或者阻塞，
其他俩还能玩，容忍一个挂。上面的场景就2，所以一个有问题，那么整体都别玩了。


#####锁粒度减小
本身设计时，lock就是单纯的为了wait而使用的，当然后来用wait也会被主动唤醒进行重置时间。
不用占用那么多lock时间，也没有那么多需要进行同步的，各自选举和心跳各自玩各自的，只不过
当心跳来时，需要重置一下选举超时时间而已。

启动8082，查看相关日志，查看是否等待投票，查看是否收到vote，查看是否
收到heartbeat。查看heartbeat频率以及是否发送vote。

停止8080，查看8081是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。
查看8082是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。

暂停8080，查看8081是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。
查看8082是否不在收到heartbeat，是否准备投票，发起投票后，
是否收到vote，是否成为leader，进而是否发送heartbeat，是否持续。
查看8080相关日志。
然后继续8080，查看term相关是否导致他的heartbeat被拒绝，然后他是否
能成为follower，然后查看8081和8082的反应。

暂停非leader机器，查看leader和其他follower的反应。
再恢复leader，查看所有机器的日志。


查看genElectionTime生成次数是否过多。

发送投票了，然后收到vote了如何办？收到heartbeat如何办？

有无并发问题？